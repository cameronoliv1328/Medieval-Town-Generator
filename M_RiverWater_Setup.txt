// =============================================================================
// M_RiverWater — Material Setup Guide (UE5)
// =============================================================================
//
// This material works with the vertex data generated by SpawnImprovedRiverMeshes():
//
// VERTEX DATA AVAILABLE:
//   UV0.x = 0..1 across river width (0=left edge, 1=right edge)
//   UV0.y = cumulative flow-scaled V coordinate (tiles along flow direction)
//   VertexColor.R = flow speed (0..255 → 0..1)
//   VertexColor.G = rapids foam mask from curvature
//   VertexColor.B = depth at center (for reference)
//   VertexColor.A = 255
//   Tangent = flow direction vector (X,Y components)
//
// =============================================================================
//
// MATERIAL SETUP (step-by-step in UE5 Material Editor):
//
// ─── 1. Material Properties ──────────────────────────────────────────────────
//
//   Blend Mode:        Translucent
//   Shading Model:     Default Lit (or Surface ForwardShading for better reflections)
//   Two Sided:         OFF
//   Used with:         Static Meshes, Procedural Meshes → both checked
//
// ─── 2. Base Color (depth-based) ─────────────────────────────────────────────
//
//   // Depth gradient: shallow edges are lighter, deep center is darker
//   float DepthAlpha = abs(UV0.x - 0.5) * 2.0;  // 0 at center, 1 at edges
//   float3 DeepColor   = float3(0.02, 0.06, 0.12);  // Dark blue-green
//   float3 ShallowColor = float3(0.06, 0.15, 0.10);  // Lighter teal
//   BaseColor = lerp(DeepColor, ShallowColor, DepthAlpha);
//
//   Implementation:
//     - Subtract(UV0.x, 0.5) → Abs → Multiply(2) → "DepthAlpha"
//     - Lerp(DeepColor, ShallowColor, DepthAlpha) → Base Color
//
// ─── 3. Normal Map Flow (the "flowing water" effect) ──────────────────────────
//
//   Use two-layer flow-offset normal panning for animated water surface.
//
//   // Flow direction from vertex tangent (already set by mesh generation)
//   // The tangent is the river flow direction — use it to orient normal panning.
//
//   // Layer A: main ripple
//   float2 FlowUV_A = UV0 + VertexTangent.xy * Time * 0.15 * VertexColor.R;
//   // Layer B: secondary ripple (offset phase to avoid sliding look)
//   float2 FlowUV_B = UV0 * 1.3 + VertexTangent.xy * Time * 0.11 * VertexColor.R + 0.5;
//
//   // Sample two normal maps and blend
//   float3 NormA = Texture2DSample(T_Water_Normal, FlowUV_A);
//   float3 NormB = Texture2DSample(T_Water_Normal, FlowUV_B);
//   float3 FinalNormal = normalize(NormA + NormB);
//
//   Implementation in Material Editor:
//     1. Create two TextureCoordinate nodes with different scale
//     2. Add flow offset: Panner node using VertexTangentWS for direction
//     3. Multiply panner speed by VertexColor.R (flow speed channel)
//     4. Sample same normal map texture with both UVs
//     5. BlendAngleCorrectNormals or simple Add+Normalize
//     6. Connect to Normal pin
//
//   Recommended normal map: any tileable water normal (UE starter content has
//   T_Water_N or search Megascans for water normals).
//
// ─── 4. Opacity ──────────────────────────────────────────────────────────────
//
//   // Edges should be more transparent, center more opaque
//   float EdgeFade = saturate(1.0 - DepthAlpha * 1.5);  // Fades at edges
//   Opacity = lerp(0.7, 0.95, EdgeFade);
//
//   This makes the river edges slightly transparent, showing the riverbed
//   through the water, which is a key AAA water quality cue.
//
// ─── 5. Roughness ────────────────────────────────────────────────────────────
//
//   Roughness = 0.02;  // Very smooth for water reflections
//   // Optionally modulate by flow speed for rougher rapids:
//   Roughness = lerp(0.01, 0.08, VertexColor.R * 0.5);
//
// ─── 6. Specular ─────────────────────────────────────────────────────────────
//
//   Specular = 0.5;  // Standard water reflectance (IOR ~1.33)
//
// ─── 7. Metallic ─────────────────────────────────────────────────────────────
//
//   Metallic = 0.0;  // Water is dielectric
//
// ─── 8. Optional: Refraction ─────────────────────────────────────────────────
//
//   If using Translucent with refraction:
//     Refraction Mode: Index of Refraction
//     IOR = 1.33 (water)
//     Or use a PixelNormalOffset refraction for a simpler setup.
//
//
// =============================================================================
// M_RiverFoam — Foam Material Setup
// =============================================================================
//
// VERTEX DATA:
//   VertexColor.R = foam intensity (0=transparent, 255=bright foam)
//   VertexColor.G = flow speed
//   VertexColor.A = opacity (0 at outer edge, 200 at inner edge)
//
// MATERIAL PROPERTIES:
//   Blend Mode:     Translucent (or Additive for bright foam)
//   Shading Model:  Unlit (foam doesn't need complex lighting)
//
// SETUP:
//   BaseColor = float3(0.9, 0.95, 1.0);  // Near-white foam
//   Opacity = VertexColor.R * VertexColor.A * (1/255.0);
//   // Animate with noise:
//   float FoamNoise = Texture2DSample(T_Noise, UV0 + Time * 0.08).r;
//   Opacity *= FoamNoise;
//
// =============================================================================
// M_RiverShore — Shore/Bank Blend Material Setup
// =============================================================================
//
// This material makes the shore strips blend with the terrain.
// Ideally, use the SAME material as your GroundMaterial but with
// vertex color wetness modulation.
//
// VERTEX DATA:
//   VertexColor.R = wetness (255=wet near water, 0=dry)
//   VertexColor.G = bank blend mask
//   UV0.x = ring fraction (0=water edge, 1=dry terrain edge)
//
// SIMPLEST APPROACH: Just use GroundMaterial.
//   The shore mesh already samples terrain heights, so it sits flush.
//   Any visible seam is hidden by the water surface overlap.
//
// BETTER APPROACH: GroundMaterial with wetness darkening:
//   float Wetness = VertexColor.R / 255.0;
//   BaseColor = GroundColor * lerp(1.0, 0.5, Wetness);  // Darken wet areas
//   Roughness = lerp(BaseRoughness, 0.1, Wetness);  // Wet = smoother
//
// BEST APPROACH: Material Instance with parameter:
//   Create a Material Instance of GroundMaterial
//   Add a "WetnessMultiplier" parameter driven by VertexColor.R
//   This lets the shore blend seamlessly with terrain while showing wetness.
//
// =============================================================================
// PERFORMANCE NOTES
// =============================================================================
//
// - Water surface: ~2 * NumSamples vertices (lightweight)
// - Riverbed: ~5 * NumSamples vertices (U-shaped cross section)
// - Shore blend: ~2 * (NumRings+1) * NumSamples vertices (biggest mesh)
// - Foam: ~4 * NumSamples vertices
//
// With NumSamples ~80 (typical for a TownRadius=18000 river):
//   Total: ~1300 vertices — negligible for modern GPUs.
//
// The adaptive terrain mesh is the bigger cost. With RiverAdaptiveTerrainCellSize=100
// and TownRadius=18000, the terrain grid is ~360x360 = ~130K vertices.
// This is still well within budget for a single procedural mesh.
// If performance is tight, increase RiverAdaptiveTerrainCellSize to 200.
//
